{"version":3,"file":"vue-i18n-extract.modern.js","sources":["../../src/report-command/vue-files.ts","../../src/report-command/language-files.ts","../../src/report-command/report.ts","../../src/index.ts","../../src/report-command/index.ts"],"sourcesContent":["import { SimpleFile, I18NItem } from '../types';\nimport isValidGlob from 'is-valid-glob';\nimport glob from 'glob';\nimport fs from 'fs';\n\nexport function readVueFiles (src: string): SimpleFile[] {\n  if (!isValidGlob(src)) {\n    throw new Error(`vueFiles isn't a valid glob pattern.`);\n  }\n\n  const targetFiles = glob.sync(src);\n\n  if (targetFiles.length === 0) {\n    throw new Error('vueFiles glob has no files.');\n  }\n\n  return targetFiles.map((f) => {\n    const fileName = f.replace(process.cwd(), '');\n    return { fileName, path: f, content: fs.readFileSync(f, 'utf8') };\n  });\n}\n\nfunction* getMatches (file: SimpleFile, regExp: RegExp, captureGroup = 1): IterableIterator<I18NItem> {\n  while (true) {\n    const match = regExp.exec(file.content);\n    if (match === null) {\n      break;\n    }\n    const line = (file.content.substring(0, match.index).match(/\\n/g) || []).length + 1;\n    yield {\n      path: match[captureGroup],\n      line,\n      file: file.fileName,\n    };\n  }\n}\n\n/**\n * Extracts translation keys from methods such as `$t` and `$tc`.\n *\n * - **regexp pattern**: (?:[$ .]tc?)\\(\n *\n *   **description**: Matches the sequence t( or tc(, optionally with either “$”, “.” or “ ” in front of it.\n *\n * - **regexp pattern**: ([\"'`])\n *\n *   **description**: 1. capturing group. Matches either “\"”, “'”, or “`”.\n *\n * - **regexp pattern**: ((?:[^\\\\]|\\\\.)*?)\n *\n *   **description**: 2. capturing group. Matches anything except a backslash\n *   *or* matches any backslash followed by any character (e.g. “\\\"”, “\\`”, “\\t”, etc.)\n *\n * - **regexp pattern**: \\1\n *\n *   **description**: matches whatever was matched by capturing group 1 (e.g. the starting string character)\n *\n * @param file a file object\n * @returns a list of translation keys found in `file`.\n */\n function extractMethodMatches (file: SimpleFile): I18NItem[] {\n  const methodRegExp = /(?:[$ .]tc?)\\(\\s*?([\"'`])((?:[^\\\\]|\\\\.)*?)\\1/g;\n  return [ ...getMatches(file, methodRegExp, 2) ];\n}\n\nfunction extractComponentMatches (file: SimpleFile): I18NItem[] {\n  const componentRegExp = /(?:<i18n|<I18N)(?:.|\\n)*?(?:[^:]path=(\"|'))(.*?)\\1/g;\n  return [ ...getMatches(file, componentRegExp, 2) ];\n}\n\nfunction extractDirectiveMatches (file: SimpleFile): I18NItem[] {\n  const directiveRegExp = /v-t=\"'(.*?)'\"/g;\n  return [ ...getMatches(file, directiveRegExp) ];\n}\n\nfunction extractI18nItemsFromVueFiles (sourceFiles: SimpleFile[]): I18NItem[] {\n  return sourceFiles.reduce((accumulator, file) => {\n    const methodMatches = extractMethodMatches(file);\n    const componentMatches = extractComponentMatches(file);\n    const directiveMatches = extractDirectiveMatches(file);\n    return [\n      ...accumulator,\n      ...methodMatches,\n      ...componentMatches,\n      ...directiveMatches,\n    ];\n  }, [] as I18NItem[]);\n}\n\nexport function parseVueFiles (vueFilesPath: string): I18NItem[] {\n  const filesList = readVueFiles(vueFilesPath);\n  return extractI18nItemsFromVueFiles(filesList);\n}\n","import path from 'path';\nimport fs from 'fs';\nimport glob from 'glob';\nimport dot from 'dot-object';\nimport yaml from 'js-yaml';\nimport isValidGlob from 'is-valid-glob';\nimport { SimpleFile, I18NLanguage, I18NItem } from '../types';\n\nimport esm from 'esm';\nrequire = esm(module);\n\nfunction readLangFiles (src: string): SimpleFile[] {\n  if (!isValidGlob(src)) {\n    throw new Error(`languageFiles isn't a valid glob pattern.`);\n  }\n\n  const targetFiles = glob.sync(src);\n\n  if (targetFiles.length === 0) {\n    throw new Error('languageFiles glob has no files.');\n  }\n\n  return targetFiles.map(f => {\n    const langPath = path.resolve(process.cwd(), f);\n\n    const extension = langPath.substring(langPath.lastIndexOf('.')).toLowerCase();\n    const isYaml = extension === '.yaml' || extension === '.yml';\n\n    const langModule = (isYaml) ? yaml.safeLoad(fs.readFileSync(langPath, 'utf8')) : require(langPath);\n    const langObj = (langModule.default) ? langModule.default : langModule;\n\n    const fileName = f.replace(process.cwd(), '');\n\n    return { fileName, path: f, content: JSON.stringify(langObj) };\n  });\n}\n\nfunction extractI18nItemsFromLanguageFiles (languageFiles: SimpleFile[]): I18NLanguage {\n  return languageFiles.reduce((accumulator, file) => {\n    const language = file.fileName.substring(file.fileName.lastIndexOf('/') + 1, file.fileName.lastIndexOf('.'));\n\n    const flattenedObject = dot.dot(JSON.parse(file.content));\n    const i18nInFile = Object.keys(flattenedObject).map((key, index) => {\n      return {\n        line: index,\n        path: key,\n        file: file.fileName,\n      };\n    });\n\n    accumulator[language] = i18nInFile;\n    return accumulator;\n  }, {});\n}\n\nexport function writeMissingToLanguage (resolvedLanguageFiles: string, missingKeys: I18NItem[]): void {\n  const languageFiles = readLangFiles(resolvedLanguageFiles);\n  languageFiles.forEach(languageFile => {\n    const languageFileContent = JSON.parse(languageFile.content);\n\n    missingKeys.forEach(item => {\n      if (item.language && languageFile.fileName.includes(item.language) || !item.language) {\n        dot.str(item.path, '', languageFileContent);\n      }\n    });\n\n    const fileExtension = languageFile.fileName.substring(languageFile.fileName.lastIndexOf('.') + 1);\n    const filePath = path.resolve(process.cwd() + languageFile.fileName);\n    const stringifiedContent = JSON.stringify(languageFileContent, null, 2);\n\n    if (fileExtension === 'json') {\n      fs.writeFileSync(filePath, stringifiedContent);\n    } else if (fileExtension === 'js') {\n      const jsFile = `export default ${stringifiedContent}; \\n`;\n      fs.writeFileSync(filePath, jsFile);\n    } else if (fileExtension === 'yaml' || fileExtension === 'yml') {\n      const yamlFile = yaml.safeDump(languageFileContent);\n      fs.writeFileSync(filePath, yamlFile);\n    }\n  });\n}\n\nexport function parseLanguageFiles (languageFilesPath: string): I18NLanguage {\n  const filesList = readLangFiles(languageFilesPath);\n  return extractI18nItemsFromLanguageFiles(filesList);\n}\n","import fs from 'fs';\nimport { I18NItem, I18NLanguage, I18NReport } from '../types';\n\nexport enum VueI18NExtractReportTypes {\n  None = 0,\n  Missing = 1 << 0,\n  Unused = 1 << 1,\n  All = ~(~0 << 2)\n};\n\n\nexport function extractI18NReport (parsedVueFiles: I18NItem[], parsedLanguageFiles: I18NLanguage, reportType: VueI18NExtractReportTypes = VueI18NExtractReportTypes.All): I18NReport {\n  const missingKeys: I18NItem[] = [];\n  const unusedKeys: I18NItem[] = [];\n\n  Object.keys(parsedLanguageFiles).forEach(language => {\n    let languageItems = parsedLanguageFiles[language];\n\n    parsedVueFiles.forEach(vueItem => {\n      const usedByVueItem = function (languageItem: I18NItem): boolean {\n        return languageItem.path === vueItem.path || languageItem.path.startsWith(vueItem.path + '.');\n      }\n\n      if (!parsedLanguageFiles[language].some(usedByVueItem)) {\n        missingKeys.push(({ ...vueItem, language }));\n      }\n\n      languageItems = languageItems.filter(languageItem => !usedByVueItem(languageItem));\n    });\n\n    unusedKeys.push(...languageItems.map((item) => ({ ...item, language })));\n  });\n\n  let extracts = {};\n  if (reportType & VueI18NExtractReportTypes.Missing) {\n    extracts = Object.assign(extracts, { missingKeys });\n  }\n  if (reportType & VueI18NExtractReportTypes.Unused) {\n    extracts = Object.assign(extracts, { unusedKeys });\n  }\n\n  return extracts;\n}\n\nexport async function writeReportToFile (report: I18NReport, writePath: string): Promise<NodeJS.ErrnoException | void> {\n  const reportString = JSON.stringify(report);\n  return new Promise((resolve, reject) => {\n    fs.writeFile(\n      writePath,\n      reportString,\n      (err) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve();\n      },\n    );\n  });\n}\n\n","import { reportCommand } from './report-command';\n\nexport default {\n  report: reportCommand\n};\n","import path from 'path';\n\nimport { ReportOptions } from '../types';\nimport { parseVueFiles } from './vue-files';\nimport { parseLanguageFiles, writeMissingToLanguage } from './language-files';\nimport { extractI18NReport, writeReportToFile } from './report';\n\nexport async function reportCommand (command: ReportOptions): Promise<void> {\n  const { vueFiles, languageFiles, output, add } = command;\n\n  const resolvedVueFiles = path.resolve(process.cwd(), vueFiles);\n  const resolvedLanguageFiles = path.resolve(process.cwd(), languageFiles);\n\n  const parsedVueFiles = parseVueFiles(resolvedVueFiles);\n  const parsedLanguageFiles = parseLanguageFiles(resolvedLanguageFiles);\n\n  const report = extractI18NReport(parsedVueFiles, parsedLanguageFiles);\n\n  if (report.missingKeys) console.table(report.missingKeys);\n  if (report.unusedKeys) console.table(report.unusedKeys);\n\n  if (output) {\n    await writeReportToFile(report, path.resolve(process.cwd(), output));\n    console.log(`The report has been has been saved to ${output}`);\n  }\n\n  if (add && report.missingKeys && report.missingKeys.length > 0) {\n    writeMissingToLanguage(resolvedLanguageFiles, report.missingKeys);\n    console.log('The missing keys have been added to your languages files');\n  }\n}\n"],"names":["getMatches","file","regExp","captureGroup","match","exec","content","line","substring","index","length","path","fileName","readLangFiles","src","isValidGlob","Error","targetFiles","glob","sync","map","f","langPath","resolve","process","cwd","extension","lastIndexOf","toLowerCase","langModule","yaml","safeLoad","fs","readFileSync","require","langObj","default","replace","JSON","stringify","VueI18NExtractReportTypes","esm","module","report","command","vueFiles","languageFiles","output","add","resolvedVueFiles","resolvedLanguageFiles","parsedVueFiles","parsedLanguageFiles","reportType","All","missingKeys","unusedKeys","Object","keys","forEach","language","languageItems","vueItem","usedByVueItem","languageItem","startsWith","some","push","filter","item","extracts","Missing","assign","Unused","extractI18NReport","readVueFiles","reduce","accumulator","extractMethodMatches","extractComponentMatches","extractDirectiveMatches","flattenedObject","dot","parse","i18nInFile","key","console","table","writePath","reportString","Promise","reject","writeFile","err","writeReportToFile","log","languageFile","languageFileContent","includes","str","fileExtension","filePath","stringifiedContent","writeFileSync","yamlFile","safeDump","writeMissingToLanguage"],"mappings":"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"}